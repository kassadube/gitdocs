{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    About.md  # test new page\n    ...       # Other markdown pages, images and other files.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    About.md  # test new page\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/about/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Mkdocs"
        },
        {
            "location": "/about/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/about/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/about/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/Fleet/roadmap/",
            "text": "Fleet Roadmap\n\n\n\n\nBuilding client side  development environment with the tools:\n\n\nNode.js\n\n    create a node.js project that will be using as a development server to build and test the fleet client.  \n\n\nwebpack configuration dev/prod.\n\n    webpack is a module bundler. webpack takes modules with dependencies and generates static assets representing those modules. As websites are evolving into web apps they are relying more and more on JavaScript.\n\n\nList of packages that will be used in the project (dependencies / devDependencies)\n\n the packages are libraries that the site will be using (React, React-Redux, Bootstrap, etc..)\n\n\n\n\n\n\nBuilding server api (Asp.core / webapi).\n\n\nCreating Authentication mechanism token based on the server side\n\n\nImplement Authentication for all ajax requests\n\n\nMapping all api requests that is being used in the messages module.\n\n\nProduce all the maped requests for the client to use.\n\n  at the beginning some of the requests might be as mock so the client will be able to test without being.\n\n\n\n\n\n\nBuilding the site state structure according to the api requests.    \n\n\nBuild Ajax action implementing the api requests and the site state.\n\n\nBuild unit test for all actions.\n\n\nCreate a dictionary mechanism server/client/database.\n\n before starting the building this item should be explain in details, this task as a potential for problems.\n\n\nbuild a datetime mechanism that should be used all over the site dates. \n\n\ncreate html skeleton using css according to the design.\n\n\n\n\nThe outcome of these tasks should be :\n\n\n\n\nGit repository in vsts.\n\n\nReadme file that explains how to clone the repository and use it.\n\nso every developer (new/old) could understand how to start using the app.\n\n\ndocument that explains all packages with the version in the time that installed.\n\n\nfolder structure for the client side.\n\n\nThe Authentication should be explained.\n\n\nEvery request should be documented with the result structure.",
            "title": "Roadmap"
        },
        {
            "location": "/Fleet/roadmap/#fleet-roadmap",
            "text": "Building client side  development environment with the tools:  Node.js \n    create a node.js project that will be using as a development server to build and test the fleet client.    webpack configuration dev/prod. \n    webpack is a module bundler. webpack takes modules with dependencies and generates static assets representing those modules. As websites are evolving into web apps they are relying more and more on JavaScript.  List of packages that will be used in the project (dependencies / devDependencies) \n the packages are libraries that the site will be using (React, React-Redux, Bootstrap, etc..)    Building server api (Asp.core / webapi).  Creating Authentication mechanism token based on the server side  Implement Authentication for all ajax requests  Mapping all api requests that is being used in the messages module.  Produce all the maped requests for the client to use. \n  at the beginning some of the requests might be as mock so the client will be able to test without being.    Building the site state structure according to the api requests.      Build Ajax action implementing the api requests and the site state.  Build unit test for all actions.  Create a dictionary mechanism server/client/database. \n before starting the building this item should be explain in details, this task as a potential for problems.  build a datetime mechanism that should be used all over the site dates.   create html skeleton using css according to the design.   The outcome of these tasks should be :   Git repository in vsts.  Readme file that explains how to clone the repository and use it. \nso every developer (new/old) could understand how to start using the app.  document that explains all packages with the version in the time that installed.  folder structure for the client side.  The Authentication should be explained.  Every request should be documented with the result structure.",
            "title": "Fleet Roadmap"
        },
        {
            "location": "/Fleet/PointerAPI/TODO/",
            "text": "TODO\n\n\nbuild webapi using asp core\n\n\nInfrastruction\n\n\n\n\n~~Add DI  (DependencyInjection)~~\n\n      currently we will use the default DI, in the future we might change it to Autofac or structuremap.\n\n\n~~Add Log mechanism using serilog.~~\n\n\n~~add support for cors.~~\n\n\n~~add support for redis cache and session management~~\n\n\n~~build authentication using JWT (javascript web token)~~\n\n\n~~Add swagger for testing api~~\n\n\nbuild test project.\n\n\nbuild multi tier app (PL, BLL, DAL)\n\n\nClean startup class separate concepts\n\n\n\n\nSite Deployment\n\n\n\n\nadd cake script\n\n\ndeploy site on iis",
            "title": "TODO"
        },
        {
            "location": "/Fleet/PointerAPI/TODO/#todo",
            "text": "",
            "title": "TODO"
        },
        {
            "location": "/Fleet/PointerAPI/TODO/#build-webapi-using-asp-core",
            "text": "",
            "title": "build webapi using asp core"
        },
        {
            "location": "/Fleet/PointerAPI/TODO/#infrastruction",
            "text": "~~Add DI  (DependencyInjection)~~ \n      currently we will use the default DI, in the future we might change it to Autofac or structuremap.  ~~Add Log mechanism using serilog.~~  ~~add support for cors.~~  ~~add support for redis cache and session management~~  ~~build authentication using JWT (javascript web token)~~  ~~Add swagger for testing api~~  build test project.  build multi tier app (PL, BLL, DAL)  Clean startup class separate concepts",
            "title": "Infrastruction"
        },
        {
            "location": "/Fleet/PointerAPI/TODO/#site-deployment",
            "text": "add cake script  deploy site on iis",
            "title": "Site Deployment"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/",
            "text": "Pointer API\n\n\nIIS Deployment\n\n\nHost ASP.NET Core on Windows with IIS\n\n\nThe new api is runing on Kestrel server while the iis use as reverse proxy.\n\nThe Kestrel web server is a new web server as part of ASP.NET Core.\n\nIt is now the preferred web server for all new ASP.NET applications.\n\nthe published site is a console app and to run it on iis we need to follow these steps:  \n\n\n\n\n\n\nInstall the \n.NET Core Windows Server Hosting bundle\n on the hosting system. The bundle installs the .NET Core Runtime, .NET Core Library, and the ASP.NET Core Module. The module creates the reverse-proxy between IIS and the Kestrel server. If the system doesn't have an Internet connection, obtain and install the Microsoft Visual C++ 2015 Redistributable before installing the .NET Core Windows Server Hosting bundle.\n\n\n\n\n\n\nRestart the system or execute net stop was /y followed by net start w3svc from a command prompt to pick up a change to the system PATH.\n\n\n\n\n\n\nCreate a new IIS Application Pool.\n\nthe \".Net Framework version:\" should be \"No Managed Code\".\n\n\n\n\n\n\nCreate new application in the iis that uses the new application pool.\n\n\n\n\n\n\nIn the new Application directory put the site published content.\n\n\n\n\n\n\nIIS reset and we are ready to go.\n\n\n\n\n\n\nSite Configuration\n\n\nThe new site uses json files for configuration instead of Web.config.\n\nthe config file named \"appsettings.production.json\"\n\n\n{\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"Data Source=DB/database.db\",\n    \"FleetConnection\": \"Data Source=207.232.46.176;Initial Catalog=Fleet;User ID=**;Password=**\"\n  },\n  \"Caching\": {\n     \"Redis\": {\n      \"Connection\": \"********************************************************,ssl=False,abortConnect=False,connectRetry=5\",\n      \"Name\": \"DEV\"\n    }\n  },\n  \"Serilog\": {\n    \"LogDirectory\": \"C:\\\\API-CORE-LOGS\",\n    \"IncludeScopes\": false,\n    \"LogLevel\": {\n       \"Default\": \"Trace\",\n      \"System\": \"Trace\",\n      \"Microsoft\": \"Trace\"\n    }\n  }\n}\n\n\n\n\nLogging\n\n\nFor logging we will use \nSeriolg\n.\n\nSerilog provides diagnostic logging with structure even data\n\n\nStructured logging\n\n\nTreating logs as data gives us greater insight into the operational activity of the systems we build. Structured logging, which is using a consistent, predetermined message format containing semantic information, builds on this technique and enables tools such as Graylog2 and Splunk to yield deeper insights. We recommend adopting structured logging because the benefits outweigh the minimal effort involved and the practice is becoming the default standard.\n\ndownload \nSeq\n to enable logging.\n\nbrowse to http://localhost:5341 to see the logs.\n\n\nSeq is enabled only for testing\n\n\nCros Origin Requests (cors)\n\n\nRedis Implementation",
            "title": "Pointerapi"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/#pointer-api",
            "text": "",
            "title": "Pointer API"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/#iis-deployment",
            "text": "",
            "title": "IIS Deployment"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/#host-aspnet-core-on-windows-with-iis",
            "text": "The new api is runing on Kestrel server while the iis use as reverse proxy. \nThe Kestrel web server is a new web server as part of ASP.NET Core. \nIt is now the preferred web server for all new ASP.NET applications. \nthe published site is a console app and to run it on iis we need to follow these steps:      Install the  .NET Core Windows Server Hosting bundle  on the hosting system. The bundle installs the .NET Core Runtime, .NET Core Library, and the ASP.NET Core Module. The module creates the reverse-proxy between IIS and the Kestrel server. If the system doesn't have an Internet connection, obtain and install the Microsoft Visual C++ 2015 Redistributable before installing the .NET Core Windows Server Hosting bundle.    Restart the system or execute net stop was /y followed by net start w3svc from a command prompt to pick up a change to the system PATH.    Create a new IIS Application Pool. \nthe \".Net Framework version:\" should be \"No Managed Code\".    Create new application in the iis that uses the new application pool.    In the new Application directory put the site published content.    IIS reset and we are ready to go.",
            "title": "Host ASP.NET Core on Windows with IIS"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/#site-configuration",
            "text": "The new site uses json files for configuration instead of Web.config. \nthe config file named \"appsettings.production.json\"  {\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"Data Source=DB/database.db\",\n    \"FleetConnection\": \"Data Source=207.232.46.176;Initial Catalog=Fleet;User ID=**;Password=**\"\n  },\n  \"Caching\": {\n     \"Redis\": {\n      \"Connection\": \"********************************************************,ssl=False,abortConnect=False,connectRetry=5\",\n      \"Name\": \"DEV\"\n    }\n  },\n  \"Serilog\": {\n    \"LogDirectory\": \"C:\\\\API-CORE-LOGS\",\n    \"IncludeScopes\": false,\n    \"LogLevel\": {\n       \"Default\": \"Trace\",\n      \"System\": \"Trace\",\n      \"Microsoft\": \"Trace\"\n    }\n  }\n}",
            "title": "Site Configuration"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/#logging",
            "text": "For logging we will use  Seriolg . \nSerilog provides diagnostic logging with structure even data",
            "title": "Logging"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/#structured-logging",
            "text": "Treating logs as data gives us greater insight into the operational activity of the systems we build. Structured logging, which is using a consistent, predetermined message format containing semantic information, builds on this technique and enables tools such as Graylog2 and Splunk to yield deeper insights. We recommend adopting structured logging because the benefits outweigh the minimal effort involved and the practice is becoming the default standard. \ndownload  Seq  to enable logging. \nbrowse to http://localhost:5341 to see the logs.  Seq is enabled only for testing",
            "title": "Structured logging"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/#cros-origin-requests-cors",
            "text": "",
            "title": "Cros Origin Requests (cors)"
        },
        {
            "location": "/Fleet/PointerAPI/pointerapi/#redis-implementation",
            "text": "",
            "title": "Redis Implementation"
        },
        {
            "location": "/Git/WhatisGit/",
            "text": "What is Git\n\n\nGit is by far, the most widely used modern version control system in the world today is Git. Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel. A staggering number of software projects rely on Git for version control, including commercial projects as well as open source. Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments).\nHaving a distributed architecture, Git is an example of a DVCS (hence Distributed Version Control System). Rather than have only one single place for the full version history of the software as is common in once-popular version control systems like CVS or Subversion (also known as SVN), in Git, every developer's working copy of the code is also a repository that can contain the full history of all changes.\n\n\nIn addition to being distributed, Git has been designed with performance, security and flexibility in mind.\n\n\nGit Install\n\n\nA Windows version of Git can be found on the \nGit download page\n .\n\n\nCreate a new Git repository\n\n\nEvery Git repository is stored in the .git folder of the directory in which the Git repository has been created. This directory contains the complete history of the repository. The .git/config file contains the configuration for the repository.\n\n\nUse the git init command to create a Git repository in the current directory. Git does not care whether you start with an empty directory or if it contains already files.\n\n\n# initialize the Git repository\n# for the current directory\n* git init\n\n\n\n\nCloning a repository\n\n\nThe git clone command copies an existing Git repository. This copy is a working Git repository with the complete history of the cloned repository. It can be used completely isolated from the original repository.\n\n\n# clone online repository\n$ git clone http://github.com/vogella/gitbook.git",
            "title": "What is Git"
        },
        {
            "location": "/Git/WhatisGit/#what-is-git",
            "text": "Git is by far, the most widely used modern version control system in the world today is Git. Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel. A staggering number of software projects rely on Git for version control, including commercial projects as well as open source. Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments).\nHaving a distributed architecture, Git is an example of a DVCS (hence Distributed Version Control System). Rather than have only one single place for the full version history of the software as is common in once-popular version control systems like CVS or Subversion (also known as SVN), in Git, every developer's working copy of the code is also a repository that can contain the full history of all changes.  In addition to being distributed, Git has been designed with performance, security and flexibility in mind.",
            "title": "What is Git"
        },
        {
            "location": "/Git/WhatisGit/#git-install",
            "text": "A Windows version of Git can be found on the  Git download page  .",
            "title": "Git Install"
        },
        {
            "location": "/Git/WhatisGit/#create-a-new-git-repository",
            "text": "Every Git repository is stored in the .git folder of the directory in which the Git repository has been created. This directory contains the complete history of the repository. The .git/config file contains the configuration for the repository.  Use the git init command to create a Git repository in the current directory. Git does not care whether you start with an empty directory or if it contains already files.  # initialize the Git repository\n# for the current directory\n* git init",
            "title": "Create a new Git repository"
        },
        {
            "location": "/Git/WhatisGit/#cloning-a-repository",
            "text": "The git clone command copies an existing Git repository. This copy is a working Git repository with the complete history of the cloned repository. It can be used completely isolated from the original repository.  # clone online repository\n$ git clone http://github.com/vogella/gitbook.git",
            "title": "Cloning a repository"
        },
        {
            "location": "/Git/gitflow/",
            "text": "Introducing GitFlow\n\n\n\n\nwhat is git flow\n\n\nGitFlow is a branching model for Git, created by Vincent Driessen.\nit is very well suited to collaboration and scaling the development team.\n\n\nKey Benefits\n\n\nParallel Development\n\n\nOne of the great things about GitFlow is that it makes parallel development very easy,by isolating new development from finished work. New development (such as features and non-emergency bug fixes) is done in feature branches, and is only merged back into main body of code when the developer(s) is happy that the code is ready for release.\nAlthough interruptions are a BadThing(tm), if you are asked to switch from one task to another, all you need to do is commit your changes and then create a new feature branch for your new task. When that task is done, just checkout your original feature branch and you can continue where you left off.\n\n\nCollaboration\n\n\nFeature branches also make it easier for two or more developers to collaborate on the same feature, because each feature branch is a sandbox where the only changes are the changes necessary to get the new feature working. That makes it very easy to see and follow what each collaborator is doing.\n\n\nRelease Staging Area\n\n\nAs new development is completed, it gets merged back into the develop branch, which is a staging area for all completed features that haven\u2019t yet been released. So when the next release is branched off of develop, it will automatically contain all of the new stuff that has been finished.\n\n\nSupport For Emergency Fixes\n\n\nGitFlow supports hotfix branches - branches made from a tagged release. You can use these to make an emergency change, safe in the knowledge that the hotfix will only contain your emergency fix. There\u2019s no risk that you\u2019ll accidentally merge in new development at the same time.\n\n\nImplementation\n\n\nDecentralized but centralized\n\n\nThe repository setup that we use and that works well with this branching model, is that with a central \u201ctruth\u201d repo. Note that this repo is only considered to be the central one (since Git is a DVCS, there is no such thing as a central repo at a technical level). We will refer to this repo as origin, since this name is familiar to all Git users.\n\n\nEach developer pulls and pushes to origin.\n\n\n\n\nThe main branches\n\n\n\n\nThe central repo holds two main branches with an infinite lifetime.\n\n\n\n\nmaster\n\n\ndevelop\n\n\n\n\nThe master branch at origin is the default branch when creating new repository at Git. Parallel to the master branch, another branch exists called develop.\n\n\nWe consider origin/master to be the main branch where the source code of HEAD always reflects a production-ready state.\n\n\nWe consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release.\n\n\nWhen the source code in the develop branch reaches a stable point and is ready to be released, all of the changes should be merged back into master somehow and then tagged with a release number.\n\n\nTherefore, each time when changes are merged back into master, this is a new production release by \ndefinition\n.\nso that theoretically, we could use a Git hook script to automatically build and roll-out our software to our production servers everytime there was a commit on master.\n\n\nSupporting branches\n\n\nNext to the main branches master and develop, our development model uses a variety of supporting branches to aid parallel development between team members, ease tracking of features, prepare for production releases and to assist in quickly fixing live production problems. Unlike the main branches, these branches always have a limited life time, since they will be removed eventually.\n\n\nThe different types of branches we may use are:\n\n\n\n\nFeature branches\n\n\nRelease branches\n\n\nHotfix branches\n\n\nBugfix branches\n\n\n\n\nEach of these branches have a specific purpose and are bound to strict rules as to which branches may be their originating branch and which branches must be their merge targets.\n\n\nBy no means are these branches \u201cspecial\u201d from a technical perspective. The branch types are categorized by how we use them. They are of course plain old Git branches.\n\n\nFeature Branches\n\n\n\n\nMust branch off from:\n\n \n develop \n\n\nMust merge back into:\n\n\n develop \n\n\nBranch naming convention:\n\n\n feature_< nameOfFeature > \n\n\nFeature branches are used to develop new features for the upcoming or a distant future release.\n\n\nFeature branch exists as long as the feature is in development, but will eventually be merged back into develop to add the new feature to the upcoming release.\n\n\nCreating Feature branch\n\n\nWhen starting work on a new feature, branch off from the develop branch.\n\n\n$ git checkout develop\n$ git checkout -b feature_newFeature\n# Switched to a new branch \"feature_newFeature\"\n\n\n\n\nIncorporating a finished feature on develop\n\n\n$ git checkout develop\n#Switched to branch 'develop'\n$ git merge --no-ff feature_newFeature\n#Updating ea1b82a..05e9557\n#(Summary of changes)\n$ git branch -d feature_newFeature\n#Deleted branch myfeature (was 05e9557).\n$ git push origin develop\n\n\n\n\nThe --no-ff flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. This avoids losing information about the historical existence of a feature branch and groups together all commits that together added the feature.\n\nIn the latter case, it is impossible to see from the Git history which of the commit objects together have implemented a feature\u2014you would have to manually read all the log messages.\n\n\nRelease Branches\n\n\nMust branch off from:\n\n \n develop \n\n\nMust merge back into:\n\n\n develop and master \n\n\nBranch naming convention:\n\n\n release_< * > \n\n\nRelease branches support preparation of a new production release.They allow for last-minute dotting of i\u2019s and crossing t\u2019s. Furthermore, they allow for minor bug fixes and preparing meta-data for a release (version number, build dates, etc.). By doing all of this work on a release branch, the develop branch is cleared to receive features for the next big release.\n\n\nThe key moment to branch off a new release branch from develop is when develop (almost) reflects the desired state of the new release. At least all features that are targeted for the release-to-be-built must be merged in to develop at this point in time.\n\n\nCreating Feature branch\n\n\nRelease branches are created from the develop branch.\n\n\n$ git checkout -b release_1.2 develop\n#Switched to a new branch \"release_1.2\"\n$ ./bump-version.sh 1.2\n#Files modified successfully, version bumped to 1.2.\n$ git commit -a -m \"Bumped version number to 1.2\"\n#[release-1.2 74d9424] Bumped version number to 1.2\n#1 files changed, 1 insertions(+), 1 deletions(-)\n\n\n\n\n\nAfter creating a new branch and switching to it, we bump the version number.\n\nThen, the bumped version number is committed.\n\n\nThis new branch may exist there for a while, until the release may be rolled out definitely. During that time, bug fixes may be applied in this branch (rather than on the develop branch). Adding large new features here is strictly prohibited. They must be merged into develop, and therefore, wait for the next big release.\n\n\nFinishing a release branch\n\n\nWhen the state of the release branch is ready to become a real release, some actions need to be carried out. First, the release branch is merged into master (since every commit on master is a new release by definition, remember). Next, that commit on master must be tagged for easy future reference to this historical version. Finally, the changes made on the release branch need to be merged back into develop, so that future releases also contain these bug fixes.\n\n\n\n$ git checkout master\n#Switched to branch 'master'\n$ git merge --no-ff release_1.2\n#Merge made by recursive.\n#(Summary of changes)\n$ git tag -a 1.2\n\n\n\n\n\nThe release is now done, and tagged for future reference. \n\nTo keep the changes made in the release branch, we need to merge those back into develop, though. \n\n\n\n$ git checkout develop\n#Switched to branch 'develop'\n$ git merge --no-ff release_1.2\n#Merge made by recursive.\n#(Summary of changes)\n\n\n\n\n\nThis step may well lead to a merge conflict (probably even, since we have changed the version number). If so, fix it and commit.\n\n\nNow we are really done and the release branch may be removed, since we don\u2019t need it anymore.\n\n\n$ git branch -d release_1.2\n#Deleted branch release_1.2 (was ff452fe).\n\n\n\n\nHotfix branches\n\n\nMay branch off from:\n\n \n master \n\n\nMust merge back into:\n\n\n develop and master \n\n\nBranch naming convention:\n\n\n hotfix_1.2.1 \n\n\nHotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned.\nThey arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.\n\n\nThe essence is that work of team members (on the develop branch) can continue, while another person is preparing a quick production fix.\n\n\nCreating the hotfix branch\n\n\nHotfix branches are created from the master branch. For example, say version 1.2 is the current production release running live and causing troubles due to a severe bug. But changes on develop are yet unstable. We may then branch off a hotfix branch and start fixing the problem:\n\n\n\n$ git checkout -b hotfix_1.2.1 master\n#Switched to a new branch \"hotfix-1.2.1\"\n$ ./bump-version.sh 1.2.1\n#Files modified successfully, version bumped to 1.2.1.\n$ git commit -a -m \"Bumped version number to 1.2.1\"\n#[hotfix_1.2.1 41e61bb] Bumped version number to 1.2.1\n#1 files changed, 1 insertions(+), 1 deletions(-)\n\n\n\n\n\nFinishing a hotfix branch\n\n\nWhen finished, the bugfix needs to be merged back into master, but also needs to be merged back into develop, in order to safeguard that the bugfix is included in the next release as well. This is completely similar to how release branches are finished.\n\n\nFirst, update master and tag the release.\n\n\n$ git checkout master\n#Switched to branch 'master'\n$ git merge --no-ff hotfix_1.2.1\n#Merge made by recursive.\n#(Summary of changes)\n$ git tag -a 1.2.1\n\n\n\n\nNext, include the bugfix in develop, too:\n\n\n$ git checkout develop\n#Switched to branch 'master'\n$ git merge --no-ff hotfix_1.2.1\n#Merge made by recursive.\n#(Summary of changes)\n\n\n\n\nFinally, remove the temporary branch:\n\n\n$ git branch -d hotfix-1.2.1\n#Deleted branch hotfix-1.2.1 (was abbe5d6).\n\n\n\n\nSummary\n\n\n\n\nGit Commands\n\n\nFeatures\n\n\nCreate a feature branch\n\n\n\n git checkout -b feature_MYFEATURE develop\n\n\n\n\n\nShare a feature branch\n\n\n$ git checkout feature_MYFEATURE\n$ git push origin feature_MYFEATURE\n\n\n\n\nGet latest for a feature branch\n\n\n$ git checkout feature_MYFEATURE\n$ git pull --rebase origin feature_MYFEATURE\n\n\n\n\nFinalize a feature branch\n\n\n$ git checkout develop\n$ git merge --no-ff feature_MYFEATURE\n$ git branch -d feature_MYFEATURE\n\n\n\n\nPush the merged feature branch\n\n\n$ git push origin develop\n$ git push origin :feature_MYFEATURE` _(if pushed)_\n\n\n\n\nReleases\n\n\nCreate a release branch\n\n\n$ git checkout -b release-1.2.0 develop\n\n\n\n\nShare a release branch\n\n\n$ git checkout release-1.2.0\n$ git push origin release-1.2.0\n\n\n\n\nGet latest for a release branch\n\n\n$  git checkout release-1.2.0\n$ git pull --rebase origin release-1.2.0\n\n\n\n\nFinalize a release branch\n\n\n$ git checkout master\n$ git merge --no-ff release-1.2.0\n$ git tag -a 1.2.0\n$ git checkout develop\n$ git merge --no-ff release-1.2.0\n$ git branch -d release-1.2.0\n\n\n\n\nPush the merged feature branch\n\n\n $ git push origin master\n $ git push origin develop\n $ git push origin --tags\n $ git push origin :release-1.2.0 _(if pushed)_\n\n\n\n\nHotfixes\n\n\nCreate a hotfix branch\n\n\n$ git checkout -b hotfix_1.2.1 [commit]\n\n\n\n\nFinalize a hotfix branch\n\n\n$ git checkout master\n$ git merge --no-ff hotfix_1.2.1\n$ git tag -a 1.2.1\n$ git checkout develop\n$ git merge --no-ff hotfix_1.2.1\n$ git branch -d hotfix_1.2.1\n\n\n\n\nPush the merged hotfix branch\n\n\n$ git push origin master\n$ git push origin develop\n$ git push origin --tags\n$ git push origin :hotfix_1.2.1 _(if pushed)_",
            "title": "GitFlow"
        },
        {
            "location": "/Git/gitflow/#introducing-gitflow",
            "text": "",
            "title": "Introducing GitFlow"
        },
        {
            "location": "/Git/gitflow/#what-is-git-flow",
            "text": "GitFlow is a branching model for Git, created by Vincent Driessen.\nit is very well suited to collaboration and scaling the development team.",
            "title": "what is git flow"
        },
        {
            "location": "/Git/gitflow/#key-benefits",
            "text": "",
            "title": "Key Benefits"
        },
        {
            "location": "/Git/gitflow/#parallel-development",
            "text": "One of the great things about GitFlow is that it makes parallel development very easy,by isolating new development from finished work. New development (such as features and non-emergency bug fixes) is done in feature branches, and is only merged back into main body of code when the developer(s) is happy that the code is ready for release.\nAlthough interruptions are a BadThing(tm), if you are asked to switch from one task to another, all you need to do is commit your changes and then create a new feature branch for your new task. When that task is done, just checkout your original feature branch and you can continue where you left off.",
            "title": "Parallel Development"
        },
        {
            "location": "/Git/gitflow/#collaboration",
            "text": "Feature branches also make it easier for two or more developers to collaborate on the same feature, because each feature branch is a sandbox where the only changes are the changes necessary to get the new feature working. That makes it very easy to see and follow what each collaborator is doing.",
            "title": "Collaboration"
        },
        {
            "location": "/Git/gitflow/#release-staging-area",
            "text": "As new development is completed, it gets merged back into the develop branch, which is a staging area for all completed features that haven\u2019t yet been released. So when the next release is branched off of develop, it will automatically contain all of the new stuff that has been finished.",
            "title": "Release Staging Area"
        },
        {
            "location": "/Git/gitflow/#support-for-emergency-fixes",
            "text": "GitFlow supports hotfix branches - branches made from a tagged release. You can use these to make an emergency change, safe in the knowledge that the hotfix will only contain your emergency fix. There\u2019s no risk that you\u2019ll accidentally merge in new development at the same time.",
            "title": "Support For Emergency Fixes"
        },
        {
            "location": "/Git/gitflow/#implementation",
            "text": "",
            "title": "Implementation"
        },
        {
            "location": "/Git/gitflow/#decentralized-but-centralized",
            "text": "The repository setup that we use and that works well with this branching model, is that with a central \u201ctruth\u201d repo. Note that this repo is only considered to be the central one (since Git is a DVCS, there is no such thing as a central repo at a technical level). We will refer to this repo as origin, since this name is familiar to all Git users.  Each developer pulls and pushes to origin.",
            "title": "Decentralized but centralized"
        },
        {
            "location": "/Git/gitflow/#the-main-branches",
            "text": "The central repo holds two main branches with an infinite lifetime.   master  develop   The master branch at origin is the default branch when creating new repository at Git. Parallel to the master branch, another branch exists called develop.  We consider origin/master to be the main branch where the source code of HEAD always reflects a production-ready state.  We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release.  When the source code in the develop branch reaches a stable point and is ready to be released, all of the changes should be merged back into master somehow and then tagged with a release number.  Therefore, each time when changes are merged back into master, this is a new production release by  definition .\nso that theoretically, we could use a Git hook script to automatically build and roll-out our software to our production servers everytime there was a commit on master.",
            "title": "The main branches"
        },
        {
            "location": "/Git/gitflow/#supporting-branches",
            "text": "Next to the main branches master and develop, our development model uses a variety of supporting branches to aid parallel development between team members, ease tracking of features, prepare for production releases and to assist in quickly fixing live production problems. Unlike the main branches, these branches always have a limited life time, since they will be removed eventually.  The different types of branches we may use are:   Feature branches  Release branches  Hotfix branches  Bugfix branches   Each of these branches have a specific purpose and are bound to strict rules as to which branches may be their originating branch and which branches must be their merge targets.  By no means are these branches \u201cspecial\u201d from a technical perspective. The branch types are categorized by how we use them. They are of course plain old Git branches.",
            "title": "Supporting branches"
        },
        {
            "location": "/Git/gitflow/#feature-branches",
            "text": "Must branch off from: \n   develop   Must merge back into:   develop   Branch naming convention:   feature_< nameOfFeature >   Feature branches are used to develop new features for the upcoming or a distant future release.  Feature branch exists as long as the feature is in development, but will eventually be merged back into develop to add the new feature to the upcoming release.",
            "title": "Feature Branches"
        },
        {
            "location": "/Git/gitflow/#creating-feature-branch",
            "text": "When starting work on a new feature, branch off from the develop branch.  $ git checkout develop\n$ git checkout -b feature_newFeature\n# Switched to a new branch \"feature_newFeature\"",
            "title": "Creating Feature branch"
        },
        {
            "location": "/Git/gitflow/#incorporating-a-finished-feature-on-develop",
            "text": "$ git checkout develop\n#Switched to branch 'develop'\n$ git merge --no-ff feature_newFeature\n#Updating ea1b82a..05e9557\n#(Summary of changes)\n$ git branch -d feature_newFeature\n#Deleted branch myfeature (was 05e9557).\n$ git push origin develop  The --no-ff flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. This avoids losing information about the historical existence of a feature branch and groups together all commits that together added the feature. \nIn the latter case, it is impossible to see from the Git history which of the commit objects together have implemented a feature\u2014you would have to manually read all the log messages.",
            "title": "Incorporating a finished feature on develop"
        },
        {
            "location": "/Git/gitflow/#release-branches",
            "text": "Must branch off from: \n   develop   Must merge back into:   develop and master   Branch naming convention:   release_< * >   Release branches support preparation of a new production release.They allow for last-minute dotting of i\u2019s and crossing t\u2019s. Furthermore, they allow for minor bug fixes and preparing meta-data for a release (version number, build dates, etc.). By doing all of this work on a release branch, the develop branch is cleared to receive features for the next big release.  The key moment to branch off a new release branch from develop is when develop (almost) reflects the desired state of the new release. At least all features that are targeted for the release-to-be-built must be merged in to develop at this point in time.",
            "title": "Release Branches"
        },
        {
            "location": "/Git/gitflow/#creating-feature-branch_1",
            "text": "Release branches are created from the develop branch.  $ git checkout -b release_1.2 develop\n#Switched to a new branch \"release_1.2\"\n$ ./bump-version.sh 1.2\n#Files modified successfully, version bumped to 1.2.\n$ git commit -a -m \"Bumped version number to 1.2\"\n#[release-1.2 74d9424] Bumped version number to 1.2\n#1 files changed, 1 insertions(+), 1 deletions(-)  After creating a new branch and switching to it, we bump the version number. \nThen, the bumped version number is committed.  This new branch may exist there for a while, until the release may be rolled out definitely. During that time, bug fixes may be applied in this branch (rather than on the develop branch). Adding large new features here is strictly prohibited. They must be merged into develop, and therefore, wait for the next big release.",
            "title": "Creating Feature branch"
        },
        {
            "location": "/Git/gitflow/#finishing-a-release-branch",
            "text": "When the state of the release branch is ready to become a real release, some actions need to be carried out. First, the release branch is merged into master (since every commit on master is a new release by definition, remember). Next, that commit on master must be tagged for easy future reference to this historical version. Finally, the changes made on the release branch need to be merged back into develop, so that future releases also contain these bug fixes.  \n$ git checkout master\n#Switched to branch 'master'\n$ git merge --no-ff release_1.2\n#Merge made by recursive.\n#(Summary of changes)\n$ git tag -a 1.2  The release is now done, and tagged for future reference.  \nTo keep the changes made in the release branch, we need to merge those back into develop, though.   \n$ git checkout develop\n#Switched to branch 'develop'\n$ git merge --no-ff release_1.2\n#Merge made by recursive.\n#(Summary of changes)  This step may well lead to a merge conflict (probably even, since we have changed the version number). If so, fix it and commit.  Now we are really done and the release branch may be removed, since we don\u2019t need it anymore.  $ git branch -d release_1.2\n#Deleted branch release_1.2 (was ff452fe).",
            "title": "Finishing a release branch"
        },
        {
            "location": "/Git/gitflow/#hotfix-branches",
            "text": "May branch off from: \n   master   Must merge back into:   develop and master   Branch naming convention:   hotfix_1.2.1   Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned.\nThey arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.  The essence is that work of team members (on the develop branch) can continue, while another person is preparing a quick production fix.",
            "title": "Hotfix branches"
        },
        {
            "location": "/Git/gitflow/#creating-the-hotfix-branch",
            "text": "Hotfix branches are created from the master branch. For example, say version 1.2 is the current production release running live and causing troubles due to a severe bug. But changes on develop are yet unstable. We may then branch off a hotfix branch and start fixing the problem:  \n$ git checkout -b hotfix_1.2.1 master\n#Switched to a new branch \"hotfix-1.2.1\"\n$ ./bump-version.sh 1.2.1\n#Files modified successfully, version bumped to 1.2.1.\n$ git commit -a -m \"Bumped version number to 1.2.1\"\n#[hotfix_1.2.1 41e61bb] Bumped version number to 1.2.1\n#1 files changed, 1 insertions(+), 1 deletions(-)",
            "title": "Creating the hotfix branch"
        },
        {
            "location": "/Git/gitflow/#finishing-a-hotfix-branch",
            "text": "When finished, the bugfix needs to be merged back into master, but also needs to be merged back into develop, in order to safeguard that the bugfix is included in the next release as well. This is completely similar to how release branches are finished.  First, update master and tag the release.  $ git checkout master\n#Switched to branch 'master'\n$ git merge --no-ff hotfix_1.2.1\n#Merge made by recursive.\n#(Summary of changes)\n$ git tag -a 1.2.1  Next, include the bugfix in develop, too:  $ git checkout develop\n#Switched to branch 'master'\n$ git merge --no-ff hotfix_1.2.1\n#Merge made by recursive.\n#(Summary of changes)  Finally, remove the temporary branch:  $ git branch -d hotfix-1.2.1\n#Deleted branch hotfix-1.2.1 (was abbe5d6).",
            "title": "Finishing a hotfix branch"
        },
        {
            "location": "/Git/gitflow/#summary",
            "text": "",
            "title": "Summary"
        },
        {
            "location": "/Git/gitflow/#git-commands",
            "text": "",
            "title": "Git Commands"
        },
        {
            "location": "/Git/gitflow/#features",
            "text": "",
            "title": "Features"
        },
        {
            "location": "/Git/gitflow/#create-a-feature-branch",
            "text": "git checkout -b feature_MYFEATURE develop",
            "title": "Create a feature branch"
        },
        {
            "location": "/Git/gitflow/#share-a-feature-branch",
            "text": "$ git checkout feature_MYFEATURE\n$ git push origin feature_MYFEATURE",
            "title": "Share a feature branch"
        },
        {
            "location": "/Git/gitflow/#get-latest-for-a-feature-branch",
            "text": "$ git checkout feature_MYFEATURE\n$ git pull --rebase origin feature_MYFEATURE",
            "title": "Get latest for a feature branch"
        },
        {
            "location": "/Git/gitflow/#finalize-a-feature-branch",
            "text": "$ git checkout develop\n$ git merge --no-ff feature_MYFEATURE\n$ git branch -d feature_MYFEATURE",
            "title": "Finalize a feature branch"
        },
        {
            "location": "/Git/gitflow/#push-the-merged-feature-branch",
            "text": "$ git push origin develop\n$ git push origin :feature_MYFEATURE` _(if pushed)_",
            "title": "Push the merged feature branch"
        },
        {
            "location": "/Git/gitflow/#releases",
            "text": "",
            "title": "Releases"
        },
        {
            "location": "/Git/gitflow/#create-a-release-branch",
            "text": "$ git checkout -b release-1.2.0 develop",
            "title": "Create a release branch"
        },
        {
            "location": "/Git/gitflow/#share-a-release-branch",
            "text": "$ git checkout release-1.2.0\n$ git push origin release-1.2.0",
            "title": "Share a release branch"
        },
        {
            "location": "/Git/gitflow/#get-latest-for-a-release-branch",
            "text": "$  git checkout release-1.2.0\n$ git pull --rebase origin release-1.2.0",
            "title": "Get latest for a release branch"
        },
        {
            "location": "/Git/gitflow/#finalize-a-release-branch",
            "text": "$ git checkout master\n$ git merge --no-ff release-1.2.0\n$ git tag -a 1.2.0\n$ git checkout develop\n$ git merge --no-ff release-1.2.0\n$ git branch -d release-1.2.0",
            "title": "Finalize a release branch"
        },
        {
            "location": "/Git/gitflow/#push-the-merged-feature-branch_1",
            "text": "$ git push origin master\n $ git push origin develop\n $ git push origin --tags\n $ git push origin :release-1.2.0 _(if pushed)_",
            "title": "Push the merged feature branch"
        },
        {
            "location": "/Git/gitflow/#hotfixes",
            "text": "",
            "title": "Hotfixes"
        },
        {
            "location": "/Git/gitflow/#create-a-hotfix-branch",
            "text": "$ git checkout -b hotfix_1.2.1 [commit]",
            "title": "Create a hotfix branch"
        },
        {
            "location": "/Git/gitflow/#finalize-a-hotfix-branch",
            "text": "$ git checkout master\n$ git merge --no-ff hotfix_1.2.1\n$ git tag -a 1.2.1\n$ git checkout develop\n$ git merge --no-ff hotfix_1.2.1\n$ git branch -d hotfix_1.2.1",
            "title": "Finalize a hotfix branch"
        },
        {
            "location": "/Git/gitflow/#push-the-merged-hotfix-branch",
            "text": "$ git push origin master\n$ git push origin develop\n$ git push origin --tags\n$ git push origin :hotfix_1.2.1 _(if pushed)_",
            "title": "Push the merged hotfix branch"
        },
        {
            "location": "/Git/gitCommands/",
            "text": "Git Commands\n\n\nSetup / Config\n\n\nShow current configuration:\n\n\n$ git config --list\n\n\n\n\nShow repository configuration:\n\n\n$ git config --local --list\n\n\n\n\n\nShow global configuration:\n\n\n$ git config --global --list\n\n\n\n\n\nShow system configuration:\n\n\n$ git config --system --list\n\n\n\n\nconfig add helpfull alias\n\n\n[alias]\n    lg1 = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all\n    lg2 = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all\n    lg3 = log --graph --color --all --pretty=format:\"%C(yellow)%H%C(green)%d%C(reset)%n%x20%cd%n%x20%cn%x20(%ce)%n%x20%s%n\"\n    lg4 = log --graph --pretty=format:\"%x09%h | %<(10,trunc)%cd |%<(25,trunc)%d | %s\" --date=short\n    lg = !\"git lg1\"\n    graphviz = \"!f() { echo 'digraph git {' ; git log --pretty='format:  %h -> { %p }' \\\"$@\\\" | sed 's/[0-9a-f][0-9a-f]*/\\\"&\\\"/g' ; echo '}'; }; f\"\n    hist = log --pretty=format:\\\"%h %ad | %s%d [%an]\\\" --graph --date=short\n    changed = git show --stat --oneline\n    st = status\n    ci = commit\n    br = branch\n    co = checkout\n    df = diff\n    dc = diff --cached\n    lg = log -p\n    who = shortlog -s --\n\n    feature = \"!git checkout develop && echo feature | git\"\n    release = \"!git checkout develop && echo release | git\"\n    hotfix = \"!git checkout master && echo hotfix | git\"\n    support = \"!git checkout master && echo support | git\"\n\n    start = \"!read BRANCH && git checkout -b $BRANCH_$1 && echo Starting\"\n    finish = \"!read BRANCH && git merge $BRANCH_$1 --no-ff && git checkout develop && git merge $BRANCH_$1 --no-ff && echo Merging\"\n\n   publish = \"!git push origin `git symbolic-ref --short HEAD` && echo Publishing\"\n\n\n\n\n\n\n\nCreate\n\n\nClone an existing repository:\n\n\nThere are two ways:\n\n\nVia SSH\n\n\n$ git clone ssh://user@domain.com/repo.git\n\n\n\n\nVia HTTP\n\n\n$ git clone http://domain.com/user/repo.git\n\n\n\n\nCreate a new local repository:\n\n\n\n$ git init\n\n\n\n\n\n\n\n\ngit log\n\n\nshort log\n\n\n\n    git log --oneline --decorate\n\n\n\n\n\nTo see a very compressed log where each commit is one line\n\n\n\ngit log --online\ngit log --pretty=oneline\n\n\n\n\n\nshow reflog\n\n\n\ngit reflog\n\n\n\n\n\nOr maybe you want to see an ASCII art tree of all the branches, decorated with the names of tags and branches:\n\n\n\ngit log --graph --oneline --decorate --all\n\n\n\n\n\nlog to a text file\n\n\n\ngit log --all --oneline -50 > log50_latest_commits.txt\ngit log --graph --oneline --decorate --all > graph_commits.txt\n\n\n\n\n\n\n* git log --no-merges --stat --reverse master..\n# since forked from master \n\n\n\n\n\nGet commit that exists in one branch and not the other\n\n\n\n* git log feature_gitflowdoc...develop\n# xcxcxcxc\n\n\n\n\n\nGit Branch\n\n\ncreate new local branch and checkout\n\n\n\n* git checkout -b newbranchName\n\n\n\n\n\ndelete branch\n\n\n\ngit branch -d branchNametoDel\n# delete from local\ngit push origin :branchNametoDel\n# delete from remote\n\n\n\n\n\nshow all branches with there last commit\n\n\n\n* git branch -avv\n\n\n\n\n\nupdate remote branches \n\n\n$ git remote update origin --p\n\n\n\n\nGit Commit\n\n\ndelete last commit in a branch and move the changes back to staging.\n\n\n\n git reset HEAD~\n\n\n\n\n\nGit diff\n\n\nshow difference only by filename\n\n\n\ngit diff branch/hash --name-only\ngit diff branch/hash --stat",
            "title": "Cheat sheet"
        },
        {
            "location": "/Git/gitCommands/#git-commands",
            "text": "",
            "title": "Git Commands"
        },
        {
            "location": "/Git/gitCommands/#setup-config",
            "text": "",
            "title": "Setup / Config"
        },
        {
            "location": "/Git/gitCommands/#show-current-configuration",
            "text": "$ git config --list",
            "title": "Show current configuration:"
        },
        {
            "location": "/Git/gitCommands/#show-repository-configuration",
            "text": "$ git config --local --list",
            "title": "Show repository configuration:"
        },
        {
            "location": "/Git/gitCommands/#show-global-configuration",
            "text": "$ git config --global --list",
            "title": "Show global configuration:"
        },
        {
            "location": "/Git/gitCommands/#show-system-configuration",
            "text": "$ git config --system --list",
            "title": "Show system configuration:"
        },
        {
            "location": "/Git/gitCommands/#config-add-helpfull-alias",
            "text": "[alias]\n    lg1 = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all\n    lg2 = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all\n    lg3 = log --graph --color --all --pretty=format:\"%C(yellow)%H%C(green)%d%C(reset)%n%x20%cd%n%x20%cn%x20(%ce)%n%x20%s%n\"\n    lg4 = log --graph --pretty=format:\"%x09%h | %<(10,trunc)%cd |%<(25,trunc)%d | %s\" --date=short\n    lg = !\"git lg1\"\n    graphviz = \"!f() { echo 'digraph git {' ; git log --pretty='format:  %h -> { %p }' \\\"$@\\\" | sed 's/[0-9a-f][0-9a-f]*/\\\"&\\\"/g' ; echo '}'; }; f\"\n    hist = log --pretty=format:\\\"%h %ad | %s%d [%an]\\\" --graph --date=short\n    changed = git show --stat --oneline\n    st = status\n    ci = commit\n    br = branch\n    co = checkout\n    df = diff\n    dc = diff --cached\n    lg = log -p\n    who = shortlog -s --\n\n    feature = \"!git checkout develop && echo feature | git\"\n    release = \"!git checkout develop && echo release | git\"\n    hotfix = \"!git checkout master && echo hotfix | git\"\n    support = \"!git checkout master && echo support | git\"\n\n    start = \"!read BRANCH && git checkout -b $BRANCH_$1 && echo Starting\"\n    finish = \"!read BRANCH && git merge $BRANCH_$1 --no-ff && git checkout develop && git merge $BRANCH_$1 --no-ff && echo Merging\"\n\n   publish = \"!git push origin `git symbolic-ref --short HEAD` && echo Publishing\"",
            "title": "config add helpfull alias"
        },
        {
            "location": "/Git/gitCommands/#create",
            "text": "",
            "title": "Create"
        },
        {
            "location": "/Git/gitCommands/#clone-an-existing-repository",
            "text": "There are two ways:  Via SSH  $ git clone ssh://user@domain.com/repo.git  Via HTTP  $ git clone http://domain.com/user/repo.git",
            "title": "Clone an existing repository:"
        },
        {
            "location": "/Git/gitCommands/#create-a-new-local-repository",
            "text": "$ git init",
            "title": "Create a new local repository:"
        },
        {
            "location": "/Git/gitCommands/#git-log",
            "text": "short log  \n    git log --oneline --decorate  To see a very compressed log where each commit is one line  \ngit log --online\ngit log --pretty=oneline  show reflog  \ngit reflog  Or maybe you want to see an ASCII art tree of all the branches, decorated with the names of tags and branches:  \ngit log --graph --oneline --decorate --all  log to a text file  \ngit log --all --oneline -50 > log50_latest_commits.txt\ngit log --graph --oneline --decorate --all > graph_commits.txt  \n* git log --no-merges --stat --reverse master..\n# since forked from master   Get commit that exists in one branch and not the other  \n* git log feature_gitflowdoc...develop\n# xcxcxcxc",
            "title": "git log"
        },
        {
            "location": "/Git/gitCommands/#git-branch",
            "text": "create new local branch and checkout  \n* git checkout -b newbranchName  delete branch  \ngit branch -d branchNametoDel\n# delete from local\ngit push origin :branchNametoDel\n# delete from remote  show all branches with there last commit  \n* git branch -avv  update remote branches   $ git remote update origin --p",
            "title": "Git Branch"
        },
        {
            "location": "/Git/gitCommands/#git-commit",
            "text": "delete last commit in a branch and move the changes back to staging.  \n git reset HEAD~",
            "title": "Git Commit"
        },
        {
            "location": "/Git/gitCommands/#git-diff",
            "text": "show difference only by filename  \ngit diff branch/hash --name-only\ngit diff branch/hash --stat",
            "title": "Git diff"
        }
    ]
}